---
title: 树
tags:
  - 树
  - 数据结构
categories:
  - 数据结构
date: 2017-06-10 22:22:15
---

* 树的定义
    * 树（Tree）是 n (n>0) 个结点的有限集。n=0 时称为空树。在任意一棵非空树中：(1) 有且仅有一个特定的称为根（Root）的结点；(2) 当 n>1 时，其余结点可分为 m (m>0) 个互不相交的有限集 T1、T2、、Tm，其中每一个集合本身又是一棵树并,且称为根的子树（SubTree），如图 6-2-1 所示。
    * n>0 时根结点是唯一的，不可能存在多个根结点。
    * m>0 时，子树的个数没有限制，但它们一定是互不相交的。
* 结点的分类
    * 结点拥有的子树数称为结点的度。度为0的结点称为叶节点或终端节点；度不为0的结点称为非终端结点或分支结点。除根结点外，分支结点也称为内部结点。树的度是树内各结点度的最大值。
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsok7dma0ej20dp08jtaf.jpg)
<!-- more -->
* 结点间的关系
    * 结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。
    * 同一个双亲的孩子之间互称为兄弟。
    * 结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为改结点的子孙。
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsok7ocyrmj20a106fq42.jpg)
* 树的其他相关概念
    * 结点的层次从根开始定义起，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为堂兄弟。
    * 树中结点的最大层次称为树的深度或高度。
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsok8be8i3j20ct0710ub.jpg)
    * 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。
    * 森林（Forest）是 m (m>0) 棵互不相交的树的集合。
* 双亲表示法
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsok8q93z4j207206i0tw.jpg)
    * 这样的存储结构，我们可以根据结点的 parent 指针很容易找到它的双亲结点，所用的时间复杂度为 0 (1），直到 parent 为-1 时，表示找到了树结点的根。可如果我们要知道结点的孩子是什么，对不起，请遍历整个结构才行。
    * 添加长子域之后的表示效果
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsok9iqbwcj209p06pta8.jpg)
    * 添加右兄弟域之后的表示效果
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsok9w1gs4j208k05ydgu.jpg)
    * 存储结构的设计师一个非常灵活的过程，一个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时间复杂度好不好等。
* 孩子表示法
    * 把每个结点的孩子结点排列起来，用单链表存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsoka4lkd4j20e4097wfy.jpg)
    * 这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可，对于遍历整棵树也是很方便的，对头结点的数组循环即可。
    * 但是对于如何知道某个结点的双亲是谁比较麻烦，需要遍历整棵树才行。
* 双亲孩子表示法
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokaauf6rj20dv09f76r.jpg)
* 孩子兄弟表示法
    * 任意一颗树，它的结点的第一个孩子如果存在就是唯一的，他的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokak2srmj208e013q2x.jpg)
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokaroxlhj20ew08o0ul.jpg)
* 二叉树的定义
    * 二叉树（BinaryTree）是 n (n>=0) 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。
* 二叉树的特点
    * 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的。
    * 左子树和右子树是有顺序的，次序不能任意颠倒。就像人是双手、双脚，但显然左手、左脚和右手、右脚是不一样的，右手戴左手套、右脚穿左鞋都会极其别扭和难受
    * 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。图 6-5-3 中，树 1 和树 2 是同一棵树，但它们却是不同的二叉树。就好像你一不小心，摔伤了手，伤的是左手还是右手，对你的生活影响度是完全不同的。
* 二叉树的五种基本形态
    * 空二叉树。
    * 只有一个根结点。
    * 根结点只有左子树。
    * 根结点只有右子树。
    * 根结点既有左子树，又有右子树。
* 特殊的二叉树
    * 斜树
        * 左斜树和右斜树：所有的结点都只有左子树的二叉树叫左斜树，所有结点都是只有右子树的二叉树叫右斜树。
    * 满二叉树
        * 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。
    * 满二叉树的特点
        * 叶子只能出现在最下一层，出现在其他层就不可能达成平衡。
        * 非叶子结点的度一定是2。
        * 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。
    * 完全二叉树
        * 对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (1 <i <n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。
        * 首先从字面上要区分，完全和满的差异，满二叉树一定是一棵完全二叉“满的差异，满二叉树一定是一棵完全二叉”“”树，但完全二叉树不一定是满的。
        * 其次，完全二叉树的所有结点与同样深度的满二叉树，它们按层序编号相同的结点，是一一对应的。
        * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokb6ghb9j20cy059dgp.jpg)
    * 完全二叉树的特点
        * 叶子结点只能出现在最下两层。
        * 最下层的叶子一定集中在左部连续位置。
        * 倒数二层，若有叶子结点，一定都在右部连续位置。
        * 如果结点度为 1, 则该结点只有左孩子，即不存在只有右子树的情况。（5) 同样结点数的二叉树，完全二叉树的深度最小。
* 二叉树的性质
    * 在二叉树的第 i 层上至多有 2i-1个结点（i>1)。
    * 深度为 k 的二叉树至多有 2k -1个结点（k>1)。
    * 对任何一棵二叉树 T ，如果其终端结点数为n0,度为2的结点数为n2，则n0 = n2 + 1
    * 具有 n 个结点的完全二叉树的深度为 [log2n]+1 ([x]表示不大于x的最大整数）。
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokbfm1gvj20ja074whj.jpg)
* 二叉树顺序存储结构
    * 为了防止空间浪费，顺序存储结构一般用于完全二叉树，对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，把不存在的结点设置为“^”而已。不过如果二叉树的右子树比左子树多太多，就会造成很大的空间浪费。
        * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokccjfxzj20c005lmy1.jpg)
        * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokcmosf9j20ec02d0t9.jpg)
* 二叉链表
    * 二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokctvlvdj2088019q2x.jpg)
* 遍历二叉树
    * 二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅仅被访问一次。
* 二叉树的遍历方法：遍历二叉树的时候可以尝试填充为完全二叉树。
    * 前序遍历
        * 若二叉树为空，则空操作返回，否则访问根结点，然后前序遍历左子树，再前序遍历右子树。
        * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokd1ev7wj206t06tq3r.jpg)
    * 中序遍历
        * 若二叉树为空，则空操作返回，否则从根结点开始，终须遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。
        * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokdahur2j206n06xgmc.jpg)
    * 后序遍历
        * 规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。
        * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokdi0s7zj20710730tj.jpg)
    * 层序遍历
        * 规则是若树为空则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。
        * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokdsx3wgj206t077gme.jpg)
* 二叉树的建立
* 线索二叉树
    * 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树。
    * 对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化。
* 树转换为二叉树
    * 加线。在所有兄弟叫结点之间加一条线。
    * 去线。对树种每个结点，值保留它与第一个孩子结点连线，删除它与其他孩子结点之间的连线。
    * 层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsoke4lykvj20bw09qabz.jpg)
* 森林转换为二叉树
    * 森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟可以按照兄弟的处理办法来操作。步骤如下：
    * 把每个树转换为二叉树。
    * 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子用线连接起来。当所有的二叉树连接起来后，就得到了由森林转换来的二叉树。
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokec0nzkj20hp0by0v6.jpg)
* 二叉树转换为树
    * 加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点……哈，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将改结点与这些右孩子结点用线连接起来。
    * 去线。删除原二叉树中所有结点与其右孩子结点的连线。
    * 层次调整。使之结构层次分明。
    * ![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsokeqeksaj20ef0bldi0.jpg)
* 二叉树转换为森林
    * 判断一颗二叉树能够转换成一棵树还是森林，看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。
* 树的遍历
    * 先根遍历。先访问树的根结点，然后依次先根遍历根的每棵子树。
    * 后根遍历。先依次后根遍历每棵子树，然后再访问根结点。
* 森林的遍历
    * 前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。
    * 后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。
* 赫夫曼树及其应用
    * 从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。树的路径长度就是从树根到每一个结点的路径长度之和。
    * 结点的带权路径长度为从该结点到树根之间的路径长度与结点上权的乘积。
    * 带权路径长度WPL最小的二叉树称作赫夫曼树，或叫做最优二叉树。