---
title: 进程控制
tags:
  - 进程
categories:
  - 操作系统
date: 2017-04-11 21:33:22
---
### 进程的创建
1. 进程图
    - 用一条由父进程指向子进程的有向边来描述它们之间的父子关系。
2. 引起创建进程的事件
    - 用户登录
    - 作业调度
    - 提供服务
    - 应用请求
3. 进程的创建
    - 申请空白PCB
    - 为新进程分配资源
    - 初始化进程控制块
        - 初始化标识信息：将系统分配的标识符和父进程标识符填入新PCB中。
        - 初始化处理机状态信息：使程序计数器指向程序的入口地址，使栈指针指向栈顶。
        - 初始化处理机控制信息：将进程的状态设置为就绪状态或禁止就绪状态，对于优先级，通常是将他设置为最低优先级。
    - 将新进程插入就绪队列
<!-- more -->

### 进程的终止
1. 引起进程终止的事件
    1. 正常结束
    2. 异常结束
        - 越界错误：程序所访问的存储区已越出该进程的区域。
        - 保护错：进程试图去访问一个不允许访问的资源或文件，或者以不适当的方式进行访问，例如，进程试图去写一个只读文件。
        - 非法指令：程序试图去执行一条不存在的指令。出现该错误的原因，可能是程序错误地转移到数据区，把数据当成了指令。
        - 特权指令错：用户进程试图去执行一条只允许 OS 执行的指令。
        - 运行超时：进程的执行时间超过了指定的最大值。
        - 等待超时：进程等待某事件的时间超过了规定的最大值。
        - 算术运行错：进程试图去执行一个被禁止的运算，例如被 0 除。
        - I/O故障：在I/O过程中发生了错误等。
    3. 外界干预
        - 操作员或操作系统干预：由于某种原因，例如，发生了死锁，由操作员或操作系统终止该进程。
        - 父进程请求：由于父进程具有终止自己的任何子孙进程的权力，因而当父进程提出请求时，系统将终止该进程。
        - 父进程终止：当父进程终止时，OS 也将它的所有子孙进程终止。
2. 进程的终止过程
    1. 根据被终止进程的标识符，从 PCB 集合中检索出该进程的 PCB，从中读出该进程的状态。
    2. 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度。
    3. 若该进程还有子孙进程，还应将其所有子孙进程予以终止，以防它们成为不可控的进程。
    4. 将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。
    5. 将被终止进程(PCB)从所在队列(或链表)中移出，等待其他程序来搜集信息。

### 进程的阻塞与唤醒
1. 引起进程阻塞和唤醒的事件
    1. 请求系统服务：请求使用某资源，但是可能不能分配给请求进程，于是请求进程阻塞
    2. 启动某种操作：当进程启动某种操作后，如果该进程必须在该操作完成之后才能继续执行，则必须先使该进程阻塞，以等待该操作完成。
    3. 新数据尚未到达：对于相互合作的进程，如果其中一个进程需要先获得另一(合作)进程提供的数据后才能对数据进行处理，则只要其所需数据尚未到达，该进程只有(等待)阻塞。
    4. 无新工作可做：系统往往设置一些具有某特定功能的系统进程，每当这种进程完成任务后，便把自己阻塞起来以等待新任务到来。
2. 进程阻塞过程
    1. 由于无法继续执行，于是进程便通过调用阻塞原语 block 把自己阻塞。可见，进程的阻塞是进程自身的一种主动行为。
    2. 进入 block 过程后，由于此时该进程还处于执行状态，所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为“阻塞”，并将 PCB 插入阻塞队列。
    3. 如果系统中设置了因不同事件而阻塞的多个阻塞队列，则应将本进程插入到具有相同事件的阻塞(等待)队列。
    4. 转调度程序进行重新调度，将处理机分配给另一就绪进程并进行切换，亦即，保留被阻塞进程的处理机状态(在 PCB 中)，再按新进程的 PCB 中的处理机状态设置 CPU 的环境。
3. 进程唤醒过程
    1. 当被阻塞进程所期待的事件出现时，如 I/O 完成或其所期待的数据已经到达，则由有关进程(比如用完并释放了该 I/O 设备的进程)调用唤醒原语 wakeup( )，将等待该事件的进程唤醒。唤醒原语执行的过程是:首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB 中的现行状态由阻塞改为就绪，然后再将该 PCB 插入到就绪队列中。

### 进程的挂起与激活
1. 进程的挂起
    1. 用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起，系统将利用挂起原语 suspend( )将指定进程或处于阻塞状态的进程挂起。
    2. 首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪。
    3. 对于活动阻塞状态的进程，则将之改为静止阻塞。
    4. 把该进程的 PCB 复制到某指定的内存区域。
    5. 若被挂起的进程正在执行，则转向调度程序重新调度。
2. 进程的激活过程
    1. 父进程或用户进程请求激活指定进程，若该进程驻留在外存而内存中已有足够的空间时，则可将在外存上处于静止就绪状态的该进程换入内存。这时，系统将利用激活原语 active( )将指定进程激活。
    2. 检查该进程的现行状态，若是静止就绪，便将之改为活动就绪。
    3. 若为静止阻塞，便将之改为活动阻塞。
    4. 假如采用的是抢占调度策略，则每当有新进程进入就绪队列时，应检查是否要进行重新调度，即由调度程序将被激活进程与当前进程进行优先级的比较，如果被激活进程的优先级更低，就不必重新调度;否则，立即剥夺当前进程的运行，把处理机分配给刚被激活的进程。