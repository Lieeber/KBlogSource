---
title: Java的自动内存管理机制
tags:
  - Java
  - Java虚拟机
categories:
  - Java
date: 2017-03-11 10:31:04
---
### 运行时数据区域
Java虚拟机在执行Java程序时会把它管理的内存划分为几个不同的数据区域。每个区域有各自的用途，并且创建和销毁的时间都会有所不同，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。以下是Java虚拟机所管理的几个运行时数据区域。
![](https://ws1.sinaimg.cn/large/5cc1a78ely1fsoe263y0vj20dr0b1ju7.jpg)
<!-- more -->
1. 程序计数器
    - 每个线程都有自己独立的程序计数器，用来记录下一条要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。
2. Java虚拟机栈
    - 虚拟机栈是线程私有的，每个方法在执行时都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行完成，就对应着一个栈帧在虚拟机中入栈到出栈的过程。
    - 局部变量表存放各种基本数据类型，对象引用和returnAddress类型，其中64位长度的double和long数据会占用2个局部变量空间。
    - 局部变量表所需的内存空间在编译期间就完成了分配，在方法运行期间不会改变。
    - stackoverflowerror：线程请求的栈深度大于虚拟机允许的深度。outofmemoryerror：虚拟机栈可以动态扩展，但是扩展时无法申请到足够的内存。
3. 本地方法栈
    - 虚拟机栈执行Java方法，而本地方法栈则为虚拟机使用到的native方法服务。
    - 本地方法栈也会抛出StackOverFlowError和OutOfMemoryError异常。
4. Java堆
    - 被所有线程共享。在虚拟机启动时创建。用来存放对象实例和数组（唯一目的）。技术在发展，并不是所有对象都分配在堆上面了（JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将导致一些微妙的变化发生）。
    - Java堆是垃圾收集器管理的主要区域。有什么新生代，老年代划分，目的就是为了更好地回收内存，与存放的内容无关。
    - Java堆可以处于物理上不连续的内存中，如果堆中的内存用完，无法再扩展时，就会抛出OutOfMemoryError。
5. 方法区
    - 被所有线程共享。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
    - 在JDK1.7的hotspot中，已经把原本放在永久代的字符串常量池移出。
    - 虚拟机规范对方法区的限制非常宽松，不需要连续的内存和可以固定大小或者课扩展，可以选择不实现垃圾收集。
    - 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。
6. 运行时常量池
    - 运行时常量池是方法区的一部分。用于存放在编译期产生的各种字面量和符号引用。但是具备动态性，允许运行期间加入新的常量。当常量池无法再申请到内存时会抛出OutOfMemoryError异常。
7. 直接内存
    - 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存被频繁地调用，也可能导致OutOfMemoryError异常的出现。

### HotSpot虚拟机对象探秘
了解了虚拟机的组成，接下来需要探索的就是，对象是如何被创建，布局以及如何访问的。HotSpot是Java中比较常见的虚拟机，接下来看看在HotSpot中，java对象是如何分贝，布局和访问的。
1. 对象的创建
    - new指令->检查指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，必须先执行相应的类的检查过程。
    - 类加载检查通过后，虚拟机将为新生对象分配内存，对象所需内存大小在类加载完成时就已经确定， 分配空间的任务等于把一块确定大小的内存从Java堆中划分出来。具体采用哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
        - 指针碰撞：分配内存时，把指针向空闲空间挪动一段与对象大小相等的距离。
        - 空闲列表：维护一个列表用来记录那些内存块是可用的，分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
    - 对象创建时需要考虑并发问题。
        - 对分配内存空间的动作进行同步处理--实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。
        - 把内存分配的动作按照线程划分在不同的空间之中进行。即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB：Thread Local Allocation Buffer）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。
    - 内存分配完成需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
    - 虚拟机对对象进行必要的设置（设置对象的对象头信息）。比如这个对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。
    - 执行<init>方法。把对象按照程序员的意愿进行初始化。
2. 对象的内存布局
    - 对象头：包括两部分信息
        - 存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。
        - 类型指针，指对象指向它的类元数据指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。（查找对象的元数据信息不一定要通过对象本身，所以并不是所有的虚拟机实现都必须在对象数据上保留类型指针）。对于数组，还需要一块记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。
    - 实例数据
        - 对象真正存储的有效信息，无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。
    - 对齐填充
        - 并不是必然存在的，仅仅起着占位符的作用。对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数。当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

3. 对象的访问定位
    - 句柄访问：Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中包含了对象实例数据与类型数据各自的具体地址信息。好处是reference种存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要更改。
    - 指针访问：reference中存储的直接就是对象地址。好处是速度更快，节省了一次指针定位的时间开销，Sun HotSpot虚拟机就是使用第二种方式来进行对象访问的。



