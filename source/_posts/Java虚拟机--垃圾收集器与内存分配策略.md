---
title: 垃圾收集器与内存分配策略
tags:
  - Java
  - Java虚拟机
categories:
  - Java
date: 2017-03-15 12:03:22
---
不同的语言有不同的内存分配策略和垃圾收集技术，比如C++语言，对象的创建和回收都需要程序员手动去完成，虽然这样自由度高，但是也大大增加了程序员的工作量；Java的垃圾回收策略解放了程序员的双手，而且Java的内存分配和回收技术已经相当成熟，我们甚至在完全不必关心内存分配的情况下书写代码，但是当我们遇到内存溢出，内存泄露的问题时。如果不了解Java的回收策略，面对这些问题就会束手无策。所以对于这部分知识的了解还是很重要的。
<!-- more -->
### 怎样判断一个对象已死

1. 引用计数算法：

很多语言都采用的这种方式来判断一个对象是否已经"死去"，比如Object-C，给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不可能再被使用的。

引用计数法虽然实现简单，判定效率也很高，但是如果两个对象相互引用，就容易造成死锁。
2. 可达性分析算法：Java，C#，Lisp等都是通过这种算法来判断对象是否存活的
    - 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。如果一个对象到GC Roots没有任何引用链相连时，则证明对象是不可用的。会被判定为可回收的对象。
    - 在Java语言中，可作为GC Roots的对象包括：
        - 虚拟机栈中引用的对象。
        - 方法区中类静态属性引用的对象。
        - 方法区中常量引用的对象。
        - 本地方法栈中JNI（Native方法）引用的对象。

无论是通过引用计数算法判断对象的引用数量还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与"引用"有关，Java中引用主要分为以下几类。

3. 引用的分类（JDK1.2之后对引用的概念进行了补充）
    - 强引用：垃圾收集器永远不会回收掉被强引用引用的对象。
    - 软引用：在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行二次回收。如果这次回收还没有足够的内存，将会抛出内存溢出异常。SoftReference类
    - 弱引用：被弱引用关联的对象只能存活到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。WeakReference类
    - 虚引用 ：唯一目的就是能在这个对象被收集器回收时收到一个系统通知。PhantomReference类。

4. finalize方法
在Java中，还有一个比较特殊的方法，当一个对象不可达时，他不一定会立马被释放，要真正宣告一个对象的死亡，需要进过两次标记过程。如果对象在进行可达性分析后发现没有与CG Roots相连接的引用连，那它就会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法（覆盖且没执行过finalize方法）；对于有必要执行finalize方法的，会把对象放入到F-Queue队列中，然后执行finalize方法。如果对象在该方法中自救了，那第二次标记时就会被移除出“即将回收”集合，不会再调用finalize方法。

5. 回收方法区
在新生代中，进行一次垃圾收集一般可以回收70%-95%的空间，是不需要对方法区进行垃圾收集的，但是在永久代，效率就远低于此，因此还存在方法区的垃圾回收。主要回收两部分内容：废弃常量和无用的类。
    - 废弃常量：没有任何String对象引用常量池中的该常量。
    - 无用的类
        - 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
        - 加载该类的ClassLoader已经被回收。
        - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾回收算法

判断出一个对象"已死"之后，就需要采取算法将其回收，不同的平台虚拟机有不同的回收算法，下面是几种主流垃圾回收算法。

1. 标记清除算法
    - 效率问题：标记和清除两个过程的效率都不高。
    - 空间问题：标记清除后产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
2. 复制算法
    - 将可用的内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
    - 每次都是对整个半区进行内存回收，不用考虑内存碎片等复杂情况，实现简单，运行高效，但是代价是将内存缩小为原来的一半。
    - 将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间。
    - Eden和Survivor空间，8：1。当Survivor空间不够用时，需要依赖其他内存进行分配担保。
1. 标记-整理算法
    * 标记过程和标记-清除算法一样，但不是直接对可回收对象进行清理了，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。
2. 分代收集算法
    * 将Java堆分为新生代和老年代，新生代每次垃圾收集时都有大批对象死去，可以选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。老年代对象存活率高，没有额外空间对它进行分配担保，必须使用标记-清理或标记-整理算法进行回收。

### HotSpot的算法实现
1. 枚举根节点
    * 在可达性分析获取GC Roots 节点这个操作中，使用的都是准确性GC，虚拟机在某个位置把栈上代表引用的位置记录下来，这样在gc发生的时候就不用全部扫描，在HotSpot中使用的是一种叫做OopMap的数据结构来记录的。
2. 安全点（Safepoint）
    * 在OopMap的协助下，可以快速的完成GC Roots的枚举，但是也不能随时随地都生成OopMap，那样一方面需要更多的空间来存放这些对象，另一方面效率也会简单低下。所以只会在特定的位置来记录一下：
        * 循环的末尾。
        * 方法临返回前/调用方法的call指令后。
        * 可能抛异常的位置。
    * 安全点也是所有线程在要GC的时候停顿的位置，可以通过两种方式让线程在安全点停顿下来。
        * 抢先式中断（几乎没有虚拟机采用这种方式中断）
            * 在GC发生的时候就让所有线程都中断，如果发现哪个线程中断的地方不在安全点上，那么就恢复线程，然后让它跑到安全点上。
        * 主动式中断
            * 让GC在需要中断线程的时候不直接对线程操作，设置一个标志，让各个线程主动轮询这个标志，如果中断标志位真时就让自己中断。
3. 安全区域（Safe Region）
    * 指在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的。

### 垃圾收集器
垃圾收集器是内存回收的具体实现。不同的厂商，不同的版本的虚拟机所提供的垃圾收集器都会有很大的差别，并且提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。
1. Serial收集器
    - 最基本，发展历史最悠久的收集器；单线程收集器，在进行垃圾收集时，必须暂停其他所有的工作线程，直到收集结束；（与其他收集器的单线程相比，简单而高效，对于限定单个cpu的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在桌面应用中，停顿在几十毫秒到一百多毫秒以内，只要不是频繁发生，可以接受。)
2. ParNew收集器
    - Serial收集器的多线程版本。是许多运行在Server模式下的虚拟机中首选的新生代收集器。
3. Parallel Scavenge收集器
    - 使用复制算法的并行的多线程新生代收集器，他的目标是达到一个可控制的吞吐量[吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)]，而不是尽可能地缩短垃圾收集时用户线程的停顿时间。该收集器具有自适应调节策略。
4. Serial Old收集器
    - Serial收集器的老年代版本。同样是一个单线程收集器，使用“标记-整理”算法
5. Parallel Old 收集器
    - Parallel Scavenge收集器的老年代版本。使用多线程和”标记-整理“算法。
6. CMS收集器
    - 是一种以获取最短回收停顿时间为目标的收集器，基于“标记-清除”算法。分为初始标记，并发标记，重新标记和并发清除。其中初始标记和重新标记依然需要”Stop The World“。它有以下三个缺点：
        - 对CPU资源敏感。
        - 无法处理浮动垃圾。
        - 基于标记-清除算法实现，收集结束后会有大量空间碎片产生。
7. G1收集器
    - 并行与并发：G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU  (CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。
    - 分代收集：与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。
    - 空间整合：与 CMS 的“标记一清理”算法不同，G1 从整体来看是基于“标记一整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。
    - 可预测的停顿：这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N 毫秒，这几乎已经是实时 Java  (RTSJ）的垃圾收集器的特征了。
    - 四个步骤
        - 初始标记（Initial Marking）
        - 并发标记（Concurrent Marking）
        - 最终标记（Final Marking)
        - 筛选回收（Live Data Counting and Evacuation)

### 内存分配与回收策略
1. 对象优先在 Eden 分配
2. 大对象直接进入老年代
3. 长期存活的对象将进入老年代
4. 动态对象年龄判定
    * 为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进人老年代，无须等到 MaxTenuringThreshold 中要求的年龄。
5. 空间分配担保

